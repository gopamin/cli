package databases

import (
	"context"
	"fmt"
	"log"
	"os"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

const collectionName = "users"

type Database interface {
	GetCollection() *mongo.Collection
	Insert(name string) (string, error)
	Update(id string, newName string) (int64, error)
	Delete(id string) (int64, error)
	Fetch(id string) (User, error)
	FetchAll() ([]User, error)
}

type User struct {
	Id   primitive.ObjectID `json:"id" bson:"_id"`
	Name string             `json:"name" bson:"name"`
}

type connection struct {
	db *mongo.Client
}

func New() Database {
	host := os.Getenv("DB_HOST")
	port := os.Getenv("DB_PORT")
	username := os.Getenv("DB_USERNAME")
	password := os.Getenv("DB_ROOT_PASSWORD")

	mongoClient, err := mongo.Connect(context.Background(), options.Client().ApplyURI(fmt.Sprintf("mongodb://%s:%s@%s:%s", username, password, host, port)))
	if err != nil {
		log.Fatalln("cannot connect to MongoDB")
	}

	c := &connection{db: mongoClient}

	return c
}

func (c *connection) GetCollection() *mongo.Collection {
	database := os.Getenv("DB_NAME")

	return c.db.Database(database).Collection(collectionName)
}

func (c *connection) Insert(name string) (string, error) {
	result, err := c.GetCollection().InsertOne(
		context.Background(),
		bson.M{
			"name": name,
		},
	)
	if err != nil {
		return "", err
	}

	insertedId, ok := result.InsertedID.(primitive.ObjectID)
	if !ok {
		return "", fmt.Errorf("unexpected type for InsertedID")
	}

	return insertedId.Hex(), nil
}

func (c *connection) Update(id string, name string) (int64, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return 0, err
	}

	result, err := c.GetCollection().UpdateOne(
		context.TODO(),
		bson.D{
			{Key: "_id", Value: objectID},
		}, bson.D{
			{
				Key: "$set",
				Value: bson.D{
					{Key: "name", Value: name},
				},
			},
		},
	)
	if err != nil {
		return 0, err
	}

	return result.ModifiedCount, nil
}

func (c *connection) Delete(id string) (int64, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return 0, err
	}

	result, err := c.GetCollection().DeleteOne(context.TODO(), bson.D{
		{Key: "_id", Value: objectID},
	})
	if err != nil {
		return 0, err
	}

	return result.DeletedCount, nil
}

func (c *connection) Fetch(id string) (User, error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return User{}, err
	}

	var user User
	filter := bson.D{
		{Key: "_id", Value: objectID},
	}

	err = c.GetCollection().FindOne(context.TODO(), filter).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return User{}, fmt.Errorf("user not found with ID %s", id)
		}
		return User{}, err
	}

	return user, nil
}

func (c *connection) FetchAll() ([]User, error) {
	var users []User
	cursor, err := c.GetCollection().Find(context.TODO(), bson.D{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(context.TODO())

	for cursor.Next(context.TODO()) {
		var user User
		if err := cursor.Decode(&user); err != nil {
			return nil, err
		}
		users = append(users, user)
	}

	if err := cursor.Err(); err != nil {
		return nil, err
	}

	return users, nil
}
